import { expect, test } from 'vitest';

import { EventDispatcher } from '../../../src/Service';
import {
  Event, EventIdentifier,
  EventInterface,
  EventListener,
  OptionalPromise,
  validateEventIdentifierFromString,
  validateEventListenerTargetFromString,
} from '../../../src/Type/Definition';
import { TestLogger } from '../TestLogger';

class TestEvent extends Event{
  constructor(identifier: EventIdentifier) {
    super(identifier);
  }
}

class TestEventListener implements EventListener<TestEvent>{
  public context: Record<string, any> = {};
}

function createAnonymousEventListener(calledValue: string, stopsEvent: boolean = false): EventListener {
  return (event: EventInterface): OptionalPromise<void> => {
    const called = event.getContextValue('called') as string[];
    called.push(calledValue);
    event.setContextValue('called', called);
    if (stopsEvent) {
      event.stopPropagation();
    }
  };
}

function getEventDispatcher(): EventDispatcher {
  return new EventDispatcher(new TestLogger());
}

test('event dispatcher can be created', () => {
  const eventDispatcher = getEventDispatcher();
  expect(eventDispatcher).toBeTruthy();
  expect(eventDispatcher.hasListeners(validateEventListenerTargetFromString('some-identifier'))).toBeFalsy();
});

test('dispatching event without corresponding event listener works', () => {
  const eventDispatcher = getEventDispatcher();
  const event = new Event(validateEventIdentifierFromString('event'));
  eventDispatcher.dispatchEvent(event);
  expect(event.isPropagationStopped()).toBeFalsy();
});

test('dispatching already stopped event leads to early return', () => {
  const eventDispatcher = getEventDispatcher();
  const event = new Event(validateEventIdentifierFromString('event'));
  event.stopPropagation();
  eventDispatcher.dispatchEvent(event);
  expect(event.isPropagationStopped()).toBeTruthy();
});

test('dispatching event with single sync event listener works', async () => {
  const eventDispatcher = getEventDispatcher();
  const event = new Event(validateEventIdentifierFromString('event'), { called: [] });
  eventDispatcher.addListener(
    validateEventListenerTargetFromString('event'),
    createAnonymousEventListener('sync listener', true),
  );

  await eventDispatcher.dispatchEvent(event);
  expect(event.isPropagationStopped()).toBeTruthy();
  expect(event.getContextValue('called')).toEqual(['sync listener']);
});

test('dispatching event with single async event listener works', async () => {
  const eventDispatcher = getEventDispatcher();
  const event = new Event(validateEventIdentifierFromString('event'), { called: [] });
  eventDispatcher.addListener(
    validateEventListenerTargetFromString('event'),
    (event: EventInterface): OptionalPromise<void> => {
      return Promise.resolve().then(() => {
        const called = event.getContextValue('called') as string[];
        called.push('async listener');
        event.setContextValue('called', called);
        event.stopPropagation();
        return;
      });
    },
  );

  await eventDispatcher.dispatchEvent(event);
  expect(event.isPropagationStopped()).toBeTruthy();
  expect(event.getContextValue('called')).toEqual(['async listener']);
});

test('priority of event listeners is respected', async () => {
  const eventDispatcher = getEventDispatcher();
  const event = new Event(validateEventIdentifierFromString('event'), { called: [] });
  eventDispatcher.addListener(
    validateEventListenerTargetFromString('event'),
    createAnonymousEventListener('low prio'),
    0,
  );
  eventDispatcher.addListener(
    validateEventListenerTargetFromString('event'),
    createAnonymousEventListener('medium prio'),
    100,
  );
  eventDispatcher.addListener(
    validateEventListenerTargetFromString('event'),
    createAnonymousEventListener('high prio'),
    200,
  );

  await eventDispatcher.dispatchEvent(event);
  expect(event.isPropagationStopped()).toBeFalsy();
  expect(event.getContextValue('called')).toEqual(['high prio', 'medium prio', 'low prio']);
});

test('indirect registration priority of event listeners is respected', async () => {
  const eventDispatcher = getEventDispatcher();
  const event = new Event(validateEventIdentifierFromString('event'), { called: [] });
  eventDispatcher.addListener(validateEventListenerTargetFromString('event'), createAnonymousEventListener('first'));
  eventDispatcher.addListener(validateEventListenerTargetFromString('event'), createAnonymousEventListener('second'));
  eventDispatcher.addListener(validateEventListenerTargetFromString('event'), createAnonymousEventListener('third'));

  await eventDispatcher.dispatchEvent(event);
  expect(event.isPropagationStopped()).toBeFalsy();
  expect(event.getContextValue('called')).toEqual(['first', 'second', 'third']);
});

test('priority of event listener identifiers is respected', async () => {
  const eventDispatcher = getEventDispatcher();
  const event = new Event(validateEventIdentifierFromString('a.b.c'), { called: [] });
  eventDispatcher.addListener(validateEventListenerTargetFromString('a.b.c'), createAnonymousEventListener('first'));
  eventDispatcher.addListener(validateEventListenerTargetFromString('a.b.*'), createAnonymousEventListener('second'));
  eventDispatcher.addListener(validateEventListenerTargetFromString('a.*'), createAnonymousEventListener('third'));
  eventDispatcher.addListener(validateEventListenerTargetFromString('*'), createAnonymousEventListener('fourth'));

  await eventDispatcher.dispatchEvent(event);
  expect(event.isPropagationStopped()).toBeFalsy();
  expect(event.getContextValue('called')).toEqual(['first', 'second', 'third', 'fourth']);
});

test('stoppable stops priority chain', async () => {
  const eventDispatcher = getEventDispatcher();
  const event = new Event(validateEventIdentifierFromString('a.b.c'), { called: [] });
  eventDispatcher.addListener(validateEventListenerTargetFromString('a.b.c'), createAnonymousEventListener('first'));
  eventDispatcher.addListener(
    validateEventListenerTargetFromString('a.b.*'),
    createAnonymousEventListener('second', true),
  );
  eventDispatcher.addListener(validateEventListenerTargetFromString('a.*'), createAnonymousEventListener('third'));
  eventDispatcher.addListener(validateEventListenerTargetFromString('*'), createAnonymousEventListener('fourth'));

  await eventDispatcher.dispatchEvent(event);
  expect(event.isPropagationStopped()).toBeTruthy();
  expect(event.getContextValue('called')).toEqual(['first', 'second']);
});

test('exception in chain does not crash event dispatcher as a whole', async () => {
  const eventDispatcher = getEventDispatcher();
  const event = new Event(validateEventIdentifierFromString('test'), { called: [] });
  eventDispatcher.addListener(
    validateEventListenerTargetFromString('test'),
    createAnonymousEventListener('first'),
    250,
  );
  eventDispatcher.addListener(
    validateEventListenerTargetFromString('test'),
    (): OptionalPromise<void> => {
      throw new Error('some error');
    },
    200,
  );
  eventDispatcher.addListener(
    validateEventListenerTargetFromString('test'),
    createAnonymousEventListener('third'),
    150,
  );

  await eventDispatcher.dispatchEvent(event);
  expect(event.isPropagationStopped()).toBeFalsy();
  expect(event.getContextValue('called')).toEqual(['first', 'third']);
});

test('error in promise in chain does not crash event dispatcher as a whole', async () => {
  const eventDispatcher = getEventDispatcher();
  const event = new Event(validateEventIdentifierFromString('test'), { called: [] });
  eventDispatcher.addListener(
    validateEventListenerTargetFromString('test'),
    createAnonymousEventListener('first'),
    250,
  );
  eventDispatcher.addListener(
    validateEventListenerTargetFromString('test'),
    (): OptionalPromise<void> => {
      return new Promise((_resolve, reject) => {
        reject(new Error('Some error'));
      });
    },
    200,
  );
  eventDispatcher.addListener(
    validateEventListenerTargetFromString('test'),
    createAnonymousEventListener('third'),
    150,
  );

  await eventDispatcher.dispatchEvent(event);
  expect(event.isPropagationStopped()).toBeFalsy();
  expect(event.getContextValue('called')).toEqual(['first', 'third']);
});

test('get listeners returns empty array if no listeners are found', () => {
  const eventDispatcher = getEventDispatcher();

  const eventListeners = eventDispatcher.getListeners(validateEventListenerTargetFromString('i.do.not.exist'));
  expect(eventListeners).toHaveLength(0);
});

test('get listeners returns registered event listeners', () => {
  const eventListenerIdentifier = validateEventListenerTargetFromString('event');
  const eventDispatcher = getEventDispatcher();
  const firstEventListener = createAnonymousEventListener('first');
  eventDispatcher.addListener(eventListenerIdentifier, firstEventListener);
  const secondEventListener = createAnonymousEventListener('second');
  eventDispatcher.addListener(eventListenerIdentifier, secondEventListener);

  const eventListeners = eventDispatcher.getListeners(eventListenerIdentifier);
  expect(eventListeners).toHaveLength(2);
  expect(eventListeners).toContain(firstEventListener);
  expect(eventListeners).toContain(secondEventListener);
});

test('get listeners does not return event listener with different identifier', () => {
  const eventListenerIdentifier = validateEventListenerTargetFromString('event');
  const otherEventListenerIdentifier = validateEventListenerTargetFromString('other');
  const eventDispatcher = getEventDispatcher();
  const firstEventListener = createAnonymousEventListener('first');
  eventDispatcher.addListener(eventListenerIdentifier, firstEventListener);
  const secondEventListener = createAnonymousEventListener('second');
  eventDispatcher.addListener(otherEventListenerIdentifier, secondEventListener);

  const eventListeners = eventDispatcher.getListeners(eventListenerIdentifier);
  expect(eventListeners).toHaveLength(1);
  expect(eventListeners).toContain(firstEventListener);
});

test('has listeners works', () => {
  const eventDispatcher = getEventDispatcher();
  const eventListenerIdentifier = validateEventListenerTargetFromString('event');
  const eventListener = createAnonymousEventListener('some listener');

  expect(eventDispatcher.hasListeners(eventListenerIdentifier)).toBeFalsy();
  eventDispatcher.addListener(eventListenerIdentifier, eventListener);
  expect(eventDispatcher.hasListeners(eventListenerIdentifier)).toBeTruthy();
  eventDispatcher.removeListener(eventListenerIdentifier, eventListener);
  expect(eventDispatcher.hasListeners(eventListenerIdentifier)).toBeFalsy();
});

test('remove listener does nothing if no event listeners were defined', () => {
  const eventDispatcher = getEventDispatcher();
  const eventListenerIdentifier = validateEventListenerTargetFromString('event');
  const eventListener = createAnonymousEventListener('some listener');

  expect(eventDispatcher.removeListener(eventListenerIdentifier, eventListener)).toBeTruthy();
});

test('remove listener does nothing if the deleted event listener is not found', () => {
  const eventDispatcher = getEventDispatcher();
  const eventListenerIdentifier = validateEventListenerTargetFromString('event');
  const eventListener = createAnonymousEventListener('some listener');
  const otherEventListener = createAnonymousEventListener('other listener');
  eventDispatcher.addListener(eventListenerIdentifier, otherEventListener);

  expect(eventDispatcher.removeListener(eventListenerIdentifier, eventListener)).toBeTruthy();
});

test('remove listener does remove registered event listener', () => {
  const eventDispatcher = getEventDispatcher();
  const eventListenerIdentifier = validateEventListenerTargetFromString('event');
  const eventListener = createAnonymousEventListener('some listener');

  eventDispatcher.addListener(eventListenerIdentifier, eventListener);
  expect(eventDispatcher.hasListeners(eventListenerIdentifier)).toBeTruthy();
  eventDispatcher.removeListener(eventListenerIdentifier, eventListener);
  expect(eventDispatcher.hasListeners(eventListenerIdentifier)).toBeFalsy();
});
